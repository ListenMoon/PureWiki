[{"slug":"失落之城-主题","category":"blog","title":"失落之城-主题","description":"一个Astro主题","body":"\n[TOC]\n\n## Meta\n\n文章可用元输入如下（有一些其他的，可以自己看代码，tpyings 尚不完善，得看布局代码）\n\n```\ntitle: Markdown测试       <!-- 必须，文章标题 -->\ndescription: 描述         <!-- 描述，可用作seo，文章中暂未展示 -->\npubDate: 2022/5/12        <!-- 发布日期 -->\nupdatedDate: 2023/01/01   <!-- 修改日期-->\nheroImage: \"\"             <!-- 文章头图 -->\nheroPosition: \"\"          <!-- 文章头图显示位置，默认center -->\ntop: true                 <!-- 展示在右上方 -->\nmode: chinese             <!-- 首行缩进 -->\n```\n\n## 特性\n\n### 内嵌标题\n\n```\n[TOC]\n```\n\n效果：\n\n[TOC]\n\n### markdown 指令转 html\n\n```\n:abbr[提示]{title=\"提示\"}\n```\n\n效果：\n:abbr[提示]{title=\"提示\"}\n\n### 面板\n\n```\n::::card\n横排排版演示\n:::card-title\n横排排版演示\n:::\n::::\n\n::::card{#vertical}\n竖排排版演示\n:::card-title\n竖排排版演示\n:::\n::::\n```\n\n效果：\n::::card\n横排排版演示\n:::card-title\n横排排版演示\n:::\n::::\n::::card{#vertical}\n竖排排版演示\n:::card-title\n竖排排版演示\n:::\n::::\n\n### 配置头图为文章中的第一张图片\n\n将配置的`showArticleHeroImage`设置为 true\n\n### 启用在源文件编辑\n\n将配置的`enableRemote`设置为 true，其源码地址也需要配置\n\n-   githubEditURL\n-   githubNewURL\n\n### mermaid\n\n````\n```flow\nflowchart TD\n    A[/Christmas\\]\n    A -->|Get money| B[\\Go shopping/]\n    B --> C{Let me thinksssss<br/>ssssssssssssssssssssss<br/>sssssssssssssssssssssssssss}\n    C -->|One| D[/Laptop/]\n    C -->|Two| E[\\iPhone\\]\n    C -->|Three| F[Car]\n```\n````\n\n效果：\n\n```flow\nflowchart TD\n    A[/Christmas\\]\n    A -->|Get money| B[\\Go shopping/]\n    B --> C{Let me thinksssss<br/>ssssssssssssssssssssss<br/>sssssssssssssssssssssssssss}\n    C -->|One| D[/Laptop/]\n    C -->|Two| E[\\iPhone\\]\n    C -->|Three| F[Car]\n```\n\n### mathjax\n\n```\n    $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$\n\n    $$\tx = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n```\n\n效果：\n$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$\n$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n\n### 命令 iframe 和 iframec\n\n`iframe`为收缩框默认打开  \n`iframec`为收缩框默认关闭\n\n````\n```\n::iframe[流程图Demo]{url=/demo/字体/HarmonyOS/index.html}\n::iframec[流程图Demo]{url=/demo/字体/HarmonyOS/index.html}\n```\n````\n\n效果\n::iframe[流程图 Demo]{url=/demo/字体/HarmonyOS/index.html}\n::iframec[流程图 Demo]{url=/demo/字体/HarmonyOS/index.html}\n\n### 命令 demo\n\n````\n:::demo\n```html\n<div>\n    <div>before content<div>\n    text\n    <div>after content<div>\n</div>\n```\n:::\n````\n\n效果：\n:::demo\n\n```html\n<div>\n    <div>\n        before content\n        <div>\n            text\n            <div>\n                after content\n                <div></div>\n            </div>\n        </div>\n    </div>\n</div>\n```\n\n:::\n\n引用其他 demo:\n\n```\n::demo{path=\"/demo/字体/HarmonyOS/index.html\"}\n```\n\n效果：\n::demo{path=\"/demo/字体/HarmonyOS/index.html\"}\n\n### Tabs\n\n````\n::::::tabs{name=\"tab1\"}\n:::::tab[时间废墟]\n\n::::tabs{name=\"tab2\"}\n:::tab[时间废墟]\n```\n111\n```\n:::\n:::tab[bbb]\n222\n:::\n:::tab[ccc]\n33\n:::\n::::\n\n:::::\n:::::tab[bbb]\n222\n:::::\n:::::tab[ccc]\n33\n:::::\n::::::\n````\n效果：\n\n::::::tabs{name=\"tab1\"}\n:::::tab[时间废墟]\n\n::::tabs{name=\"tab2\"}\n:::tab[湮灭时间]\n```\n111\n```\n:::\n:::tab[bbb]\n222\n:::\n:::tab[ccc]\n33\n:::\n::::\n\n:::::\n:::::tab[bbb]\n222\n:::::\n:::::tab[ccc]\n33\n:::::\n::::::\n\n## 开发计划\n\n> 暂无新功能的想法，有啥想法的可以说\n\n-   [x] Tabs\n-   [ ] 优化代码与样式\n"},{"slug":"博客/集成评论框","category":"blog","title":"集成评论框","description":"","body":"\n## 起因\n\n对于这个博客来说，我尝试了许多评论插件，例如 giscus，utteranc，gitalk 啥的，都是基于 github 的，有的是 github 的讨论，又是 github 的 issue，这样的好处是邮件自动集成了，但用起来总感觉有点垃圾。\n\n最后，我选择了 utteranc，这个集成比较简单，不需要啥 clientID 啥的，评论输出再 github 的 issue 中。\n\n## 探索\n\n按照[官网](https://utteranc.es/)提供的集成代码来说是可以的，但是当使用了 pjax 时就需要修改了。\n\n```html\n<script\n    src=\"https://utteranc.es/client.js\"\n    repo=\"[ENTER REPO HERE]\"\n    issue-term=\"pathname\"\n    theme=\"github-light\"\n    crossorigin=\"anonymous\"\n    async\n></script>\n```\n\n由于`client.js`使用的时`document.currentScript`来定位该 script 元素，当界面刷新时自然不会有啥问题，但是 pjax 是不刷新界面二十直接替换 dom 的，即使 script 重新替换执行，[document.currentScript](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/currentScript)的值变成了`null`(由于是在 pjax 的回调中执行的，**应该是这个原因，可能得测试看看**),表示就找不到这个 script 了，也就无法替换掉 script 生成评论框了。\n\n总之呢，我们换一种方法就是了，我将上面这段代码用 document 生成然后插入到 dom 中就好了。\n\n```js 静态文件：\\libs\\utteranc.client.js\nvar script = document.createElement(\"script\");\nscript.setAttribute(\"src\", \"https://utteranc.es/client.js\");\nscript.setAttribute(\"repo\", \"ListenMoon/PureWiki\");\nscript.setAttribute(\"issue-term\", \"pathname\");\nscript.setAttribute(\"label\", \"收录\");\nscript.setAttribute(\"theme\", \"github-light\");\nscript.setAttribute(\"crossorigin\", \"anonymous\");\nscript.setAttribute(\"async\", \"\");\n\nscript.onerror = function () {\n    if (sc) {\n        sc.innerText = \"评论加载失败，刷新重试\";\n    }\n};\nvar sc = document.getElementById(\"utteranc-sc\");\n// var parentNode = sc.parentNode;\nsc.appendChild(script);\n\nif (document.currentScript && document.currentScript.parentNode) {\n    document.currentScript.parentNode.removeChild(document.currentScript);\n}\n```\n\n```html 界面上集成\n<style is:global>\n    .utterances {\n        max-width: 100% !important;\n        background: var(--mian-bg-color);\n    }\n    .utterances iframe {\n        padding: 0 25px;\n        box-sizing: border-box;\n    }\n</style>\n<div\n    id=\"utteranc-sc\"\n    style=\"text-align: center;padding: 0 0;margin: 0 1em;position:relative;min-height: 100px;margin-top:1em;\"\n>\n    <span\n        style=\"position:absolute;top: 50px;left:50%;transform: translateX(-50%);\"\n        >评论加载中...</span\n    >\n    <script is:raw src=\"/libs/utteranc.client.js\"></script>\n</div>\n```\n\n如此，替换的就是`<script is:raw src=\"/libs/utteranc.client.js\"></script>`这个 script 了。这样的话刷新跟 pjax 都是支持的。\n\n## 结论\n\n有问题思考怎么解决问题，解决不了就换个问题。\n"},{"slug":"技术/用接口返回动态图片","category":"blog","title":"用接口返回动态图片","description":"","body":"\n## 前言\n\n之前用github写东西的时候，发现很多的人的主页都有类似的东西，就是一个动态显示的图片，每访问一次会获取新的数据展示，例如：\n\n![](https://camo.githubusercontent.com/21d169bfca4edcaf870b6b55d8c4f6064a8d26d248ff60a8d33eb55e4c316fbd/68747470733a2f2f6769746875622d726561646d652d73746174732e76657263656c2e6170702f6170693f757365726e616d653d6e706d72756e2673686f775f69636f6e733d747275652669636f6e5f636f6c6f723d43453144324426746578745f636f6c6f723d3731383039362662675f636f6c6f723d66666666666626686964655f7469746c653d74727565)\n\n上面的图片对应的url如下：\n\n```\nhttps://camo.githubusercontent.com/21d169bfca4edcaf870b6b55d8c4f6064a8d26d248ff60a8d33eb55e4c316fbd/68747470733a2f2f6769746875622d726561646d652d73746174732e76657263656c2e6170702f6170693f757365726e616d653d6e706d72756e2673686f775f69636f6e733d747275652669636f6e5f636f6c6f723d43453144324426746578745f636f6c6f723d3731383039362662675f636f6c6f723d66666666666626686964655f7469746c653d74727565\n```\n\n可以看到，这并没有图片后缀，但是它可以显示图片。\n\n在此呢，这里就粗略讲一下实现。\n\n## 探究\n\n这个[仓库](https://stackblitz.com/edit/stackblitz-starters-oqdgd3?description=&file=index.js,package.json&title=Koa%20Starter)包含了源码.\n\n可以看到，这并没有图片后缀，但是它可以显示图片。\n\n在此呢，这里就粗略讲一下实现。\n\n1. 处理图片二进制流：\n\n    ```\n    const helloWorld = ctx => {\n        const avatarPath = path.resolve(__dirname, \"./public/avatar.jpg\")\n        ctx.set ('Content-Type', 'image/jpeg')\n        ctx.body = fs.createReadStream(avatarPath)\n    }\n    router.get('/', helloWorld);\n    ```\n\n2. 浏览器时按照响应头的Content-Type来处理文件的，因此我加上了上面ctx.set ('Content-Type', 'image/jpeg')的这行代码，表示让浏览器按照jpg的格式处理。\n\n当然了，还存在其他的响应头，例如：\n\n- [Content-Type-Options](https://cloud.tencent.com/developer/ask/sof/28296)\n  此标头可防止基于\"mime“的攻击\n- [Content-Disposition](https://www.cnblogs.com/wq-9/articles/12165056.html)\n  当用户想把请求所得的内容存为一个文件的时候提供一个默认的文件名,当你在响应类型为application/octet- stream情况下使用了这个头信息的话，那就意味着你不想直接显示内容，而是弹出一个\"文件下载\"的对话框，接下来就是由你来决定\"打开\"还是\"保存\" 了。有些更加具体的注意事项：https://cloud.tencent.com/developer/ask/sof/66314\n\n## 工具\n\nhttps://npm.runkit.com/mime\nhttps://www.npmjs.com/search?q=content-Type"},{"slug":"技术/CSS/CSS属性/image-rendering","category":"blog","title":"image-rendering","description":"用于设置图像缩放算法。它适用于元素本身，适用于元素其他属性中的图像，也应用于子元素。","body":"\n`image-rendering` 用于设置图像缩放算法。它适用于元素本身，适用于元素其他属性中的图像，也应用于子元素。\n\n当页面作者指定的尺寸不是图像的原始尺寸时，用户代理将缩放图像。缩放也可能由于用户互动（双指缩放）而发生。举个例子，如果有一张尺寸为 100×100px 的图片，但作者有意将尺寸设置为 200×200px（或 50×50px），然后，图片便会根据 image-rendering 指定的算法，缩小或放大到新尺寸。此属性对于未缩放的图像没有影响。\n\n## 属性值\n\n| 属性 | 描述 |\n| :--- | :--- |\n| auto |  自 Gecko 1.9（Firefox 3.0）起，Gecko 使用双线性（bilinear）算法进行重新采样（高质量）。    |\n| :abbr[smooth]{title=\"实验性\"}| 应使用能最大化图像客观观感的算法来缩放图像。特别地，会“平滑”颜色的缩放算法是可以接受的，例如双线性插值。这适用于照片等类型的图像。|\n|:abbr[high-quality]{title=\"实验性\"}|与 smooth 相同，但更倾向于高质量的缩放。如果系统资源受到限制，在考虑降低哪些图像的质量以及降低到什么程度时，high-quality 的图像应该优先于任何其他值的图像。|\n|crisp-edges|必须使用可有效保留对比度和图像中的边缘的算法来对图像进行缩放，并且，该算法既不会平滑颜色，又不会在处理过程中为图像引入模糊。合适的算法包括最近邻居（nearest-neighbor）算法和其他非平滑缩放算法，比如 2×SaI 和 hqx-* 系列算法。此属性值适用于像素艺术作品，例如一些网页游戏中的图像。|\n|pixelated|放大图像时，使用最近邻居算法，因此，图像看着像是由大块像素组成的。缩小图像时，算法与 auto 相同。|\n\n> 备注： 早期草案中出现的 optimizationQuality 和 optimizationSpeed （来自 SVG 的对应值）分别被定义为 smooth 和 pixelated。\n\n::iframe[示例]{url=\"https://interactive-examples.mdn.mozilla.net/pages/css/image-rendering.html\"}\n\n## 资料\n-   https://developer.mozilla.org/zh-CN/docs/Web/CSS/image-rendering\n-   https://segmentfault.com/q/1010000010391524\n\n"},{"slug":"技术/CSS/CSS技巧/CSS高宽不等图片固定比例布局的三重进化","category":"blog","title":"CSS高宽不等图片固定比例布局的三重进化","description":"CSS高宽不等图片固定比例布局的三重进化","body":"\n> 转载自[张鑫旭](https://www.zhangxinxu.com/)的[CSS高宽不等图片固定比例布局的三重进化](https://www.zhangxinxu.com/wordpress/2023/07/css-image-aspect-ratio-layout/)，感觉也什么需要补充的，后续学习后慢慢修改。\n侵权立删。\n\n## 前言\n\n今天从博客中学习中学习了[CSS 高宽不等图片固定比例布局的三重进化](https://www.zhangxinxu.com/wordpress/2023/07/css-image-aspect-ratio-layout/)。主要是以下下过\n\n![图片比例1:1,跟随容器大小缩放](/article/CSS高宽不等图片固定比例布局的三重进化/2023-08-19_19-09-56-22.png)\n\n那么，我们会如何实现呢？\n\n## 实现\n\n### 百分比 padding\n\n要让一个元素内容按照固定比例显示。\n\n在过去，那个还需要兼容 IE 浏览器的年代，基本上都是使用百分比 padding 实现的，因为 padding 的百分比计算值都是相对于宽度计算的，哪怕是垂直方向。\n\n例如：\n\n```css\ndiv {\n    padding: 100% 100% 0 0;\n}\n```\n\n就会撑起一个 1:1 的 div 元素。\n\n我们就可以利用此特性，让图片 1:1 高宽比弹性显示。\n\nHTML 结构如下，需要三层标签，一层宽度，一层确定高宽，最后图片填充。\n\n```html\n<ul class=\"box\">\n    <li class=\"list\">\n        <div class=\"cover\">\n            <img src=\"0.jpg\" />\n        </div>\n    </li>\n    <li class=\"list\">\n        <div class=\"cover\">\n            <img src=\"1.jpg\" />\n        </div>\n    </li>\n    ...\n</ul>\n```\n\nCSS 代码示意如下，为了兼容 IE9，特意使用了传统的浮动布局。\n\n```css\n.box {\n    overflow: hidden;\n}\n.list {\n    width: calc(25% - 1.5rem / 4);\n    float: left;\n    margin-bottom: 0.5rem;\n}\n.list:not(:nth-child(4n + 1)) {\n    margin-left: 0.5rem;\n}\n.cover {\n    padding: 100% 100% 0 0;\n    position: relative;\n}\n.cover img {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n}\n```\n\n由于 padding 占据了空间，所以图片需要使用绝对定位才能覆盖 div 元素的支撑空间。\n\n下图为实现后的效果：\n:::demo\n\n```html\n<style>\n    .box {\n        overflow: hidden;\n        list-style: none;\n    }\n    .list {\n        width: calc(25% - 1.5rem / 4);\n        float: left;\n        margin-bottom: 0.5rem;\n    }\n    .list:not(:nth-child(4n + 1)) {\n        margin-left: 0.5rem;\n    }\n    .cover {\n        padding: 100% 100% 0 0;\n        position: relative;\n    }\n    .cover img {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        object-fit: cover;\n    }\n</style>\n<div style=\"resize: horizontal;overflow: hidden;\">\n    <ul class=\"box\">\n        <li class=\"list\">\n            <div class=\"cover\">\n                <img src=\"/avatar.jpg\" />\n            </div>\n        </li>\n        <li class=\"list\">\n            <div class=\"cover\">\n                <img src=\"/avatar.jpg\" />\n            </div>\n        </li>\n        <li class=\"list\">\n            <div class=\"cover\">\n                <img src=\"/avatar.jpg\" />\n            </div>\n        </li>\n        <li class=\"list\">\n            <div class=\"cover\">\n                <img src=\"/avatar.jpg\" />\n            </div>\n        </li>\n        <li class=\"list\">\n            <div class=\"cover\">\n                <img src=\"/avatar.jpg\" />\n            </div>\n        </li>\n        <li class=\"list\">\n            <div class=\"cover\">\n                <img src=\"/avatar.jpg\" />\n            </div>\n        </li>\n    </ul>\n</div>\n```\n\n:::\n\n此布局效果其实 2017 年的时候就有详细介绍，有兴趣可以访问这里：[CSS 百分比 padding 实现比例固定图片自适应布局](https://www.zhangxinxu.com/wordpress/2017/08/css-percent-padding-image-layout/)\n\n### aspect-ratio 属性\n\n到了 2021 年，随着 CSS 技术的发展，固定比例的图片布局有了新的选择，这个就是 CSS `aspect-ratio`属性，专门设置元素的高宽比。\n\n不过此属性用在 IMG 元素上是没有效果的，因为图片元素具有内在尺寸，不受 aspect-ratio 属性影响。\n\n因此，使用 aspect-ratio 属性实现等比例图像弹性布局需要至少两层标签。\n\n```html\n<ul class=\"box\">\n    <li class=\"list\">\n        <img src=\"0.jpg\" />\n    </li>\n    <li class=\"list\">\n        <img src=\"1.jpg\" />\n    </li>\n    ...\n</ul>\n```\n\n比 padding 方法，CSS 自然也简化了些，这里使用 Flex 布局示意。\n\n```css\n.box {\n    display: flex;\n    gap: 0.5rem;\n    flex-wrap: wrap;\n}\n.list {\n    flex-basis: calc(25% - 1.5rem / 4);\n    aspect-ratio: 1 / 1;\n}\n.list img {\n    display: block;\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n}\n```\n\n是不是容易理解多了。\n\n实现效果类似下面的:\n:::demo\n\n```html\n<style>\n    .box {\n        list-style: none;\n        display: flex;\n        gap: 0.5rem;\n        flex-wrap: wrap;\n    }\n    .list {\n        flex-basis: calc(25% - 1.5rem / 4);\n        aspect-ratio: 1 / 1;\n    }\n    .list img {\n        display: block;\n        width: 100%;\n        height: 100%;\n        object-fit: cover;\n    }\n</style>\n<div style=\"resize: horizontal;overflow: hidden;\">\n    <ul class=\"box\">\n        <li class=\"list\">\n            <img src=\"/avatar.jpg\" />\n        </li>\n        <li class=\"list\">\n            <img src=\"/avatar.jpg\" />\n        </li>\n        <li class=\"list\">\n            <img src=\"/avatar.jpg\" />\n        </li>\n        <li class=\"list\">\n            <img src=\"/avatar.jpg\" />\n        </li>\n        <li class=\"list\">\n            <img src=\"/avatar.jpg\" />\n        </li>\n        <li class=\"list\">\n            <img src=\"/avatar.jpg\" />\n        </li>\n    </ul>\n</div>\n```\n\n:::\n\n关于`aspect-ratio`属性更多信息，例如和 width/height 等属性相比的优先级等，可以参考之前的这篇文章：[Chrome 88 已经支持 aspect-ratio 属性了，学起来](https://www.zhangxinxu.com/wordpress/2021/02/css-aspect-ratio/).\n\n### cqw 单位\n\n到了如今的 2023 年，又有了更加简单的方法，实现最终的布局需要只需要一层容器标签即可。\n\n```html\n<div class=\"box\">\n    <img src=\"0.jpg\" />\n    <img src=\"1.jpg\" />\n    <img src=\"2.jpg\" />\n    <img src=\"3.jpg\" />\n    <img src=\"4.jpg\" />\n    <img src=\"5.jpg\" />\n</div>\n```\n\n这么给力，那是用什么东西实现的呢？\n\n嘿嘿，容器元素和 cqw 单位，具体 CSS 如下所示:\n\n```css\n.box {\n    display: flex;\n    gap: 0.5rem;\n    flex-wrap: wrap;\n    container-type: inline-size;\n}\n.box img {\n    width: calc(25cqw - 1.5rem / 4);\n    height: calc(25cqw - 1.5rem / 4);\n    object-fit: cover;\n}\n```\n\n`container-type:inline-size`可以让普通元素变成 container 容器元素，而 cqw 是容器宽度单位，1cqw=1%的容器宽度，100cqw 就是容器宽度。\n\n而本需求需要一行显示 4 个图片，因此，每个图片相对于容器的大小就很好计算了。\n\n就是这么简单。\n\n效果一样：\n\n:::demo\n\n```html\n<style>\n    .box {\n        list-style: none;\n        display: flex;\n        gap: 0.5rem;\n        flex-wrap: wrap;\n        container-type: inline-size;\n    }\n    .box img {\n        width: calc(25cqw - 1.5rem / 4);\n        height: calc(25cqw - 1.5rem / 4);\n        object-fit: cover;\n    }\n</style>\n<div style=\"resize: horizontal;overflow: hidden;\">\n    <div class=\"box\">\n        <img src=\"/avatar.jpg\" />\n        <img src=\"/avatar.jpg\" />\n        <img src=\"/avatar.jpg\" />\n        <img src=\"/avatar.jpg\" />\n        <img src=\"/avatar.jpg\" />\n        <img src=\"/avatar.jpg\" />\n    </div>\n</div>\n```\n\n:::\n\n`@container`容器规则还是很强很实用的，具体可以访问[介绍 2022 最期待且已正式支持的 CSS container 容器查询](https://www.zhangxinxu.com/wordpress/2022/09/css-container-rule/)了解更多.\n"},{"slug":"技术/Vue/Vue3/推荐","category":"blog","title":"推荐","body":"\n::collect[极致舒适的 Vue 弹窗使用方案]{url=\"https://juejin.cn/post/7253062314306322491#heading-6||地址\"}\n"},{"slug":"技术/Vue/Vue3/有关computed的各种详细操作","category":"blog","title":"有关computed的各种详细操作","description":"","body":"\n## 官方概念\n\n该属性是属于 vue 的概念之一，主要作用就是结合响应式值，组合成一个新的值，并且会随着响应式值的更新而更新。比之使用函数来说，能够做到对值的缓存，响应式值不变化的时候值也不会变化，而函数只要重新渲染就会执行。\n\n为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 list，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 list。没有缓存的话，我们会重复执行非常多次 list 的 getter，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。\n\n### 可写计算属性\n\n计算属性默认是只读的。但计算属性也是可以写入的，当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：\n\n```js\n<script setup>\nimport { ref, computed } from 'vue'\n\nconst firstName = ref('John')\nconst lastName = ref('Doe')\n\nconst fullName = computed({\n  // getter\n  get() {\n    return firstName.value + ' ' + lastName.value\n  },\n  // setter\n  set(newValue) {\n    // 注意：我们这里使用的是解构赋值语法\n    [firstName.value, lastName.value] = newValue.split(' ')\n  }\n})\n</script>\n```\n\n现在当你再运行 fullName.value = 'John Doe' 时，setter 会被调用而 firstName 和 lastName 会随之更新。\n\n### 注意\n\n-   **Getter 不应有副作用**\n\n    计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，不要在 getter 中做异步请求或者更改 DOM！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用侦听器根据其他响应式状态的变更来创建副作用。\n\n-   **避免直接修改计算属性值**\n\n    从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。\n\n> 以上部分是简要摘出了官方文档的内容。\n\n## 项目实践\n\n我们主要记录用`computed`能够实现怎样简便与优雅的操作。\n\n### 对话框的显隐控制\n\n```html\n<script setup lang=\"ts\">\n    import { computed } from \"vue\";\n    import { ElDialog } from \"element-plus\";\n\n    const props = defineProps<{\n        visible: boolean;\n        title?: string;\n    }>();\n\n    const emits = defineEmits<{\n        (event: \"update:visible\", visible: boolean): void;\n        (event: \"close\"): void;\n    }>();\n\n    const dialogVisible = computed<boolean>({\n        get() {\n            return props.visible;\n        },\n        set(visible) {\n            emits(\"update:visible\", visible);\n            if (!visible) {\n                emits(\"close\");\n            }\n        },\n    });\n</script>\n\n<template>\n    <ElDialog v-model=\"dialogVisible\" :title=\"title\" width=\"30%\">\n        <span>This is a message</span>\n        <template #footer>\n            <span>\n                <el-button @click=\"dialogVisible = false\">Cancel</el-button>\n                <el-button type=\"primary\" @click=\"dialogVisible = false\">\n                    Confirm\n                </el-button>\n            </span>\n        </template>\n    </ElDialog>\n</template>\n```\n\n解析：\n\n可以看到`dialogVisible`是一个计算属性，当读取它时，获取到的是`props.visible`的值，当执行`dialogVisible.value = false`是，会走 set 的函数，即`emit`事件给父组件，实现了方便快捷的`v-model`支持，避免了使用`watch`。\n\n不过，可以确定的是，这种方式只能用于一个值的,如果需要多个值组合响应，最好还是要用`watch`好控制一点。\n\n### 其他示例暂未想到\n\n## 附件资料\n\n-   https://cn.vuejs.org/guide/essentials/computed.html\n-   https://cn.vuejs.org/api/reactivity-core.html#computed\n-   https://cn.vuejs.org/api/options-state.html#computed\n"}]