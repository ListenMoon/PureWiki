[{"slug":"PureWiki主题","category":"blog","title":"PureWiki主题","description":"一个简单的主题","body":"\n[TOC]\n\n## 特性\n\n1. 文章可用元输入如下（有一些其他的，可以自己看代码，tpyings 尚不完善，得看布局代码）\n\n    ```\n    title: Markdown测试       <!-- 必须，文章标题 -->\n    description: 描述         <!-- 描述，可用作seo，文章中暂未展示 -->\n    pubDate: 2022/5/12        <!-- 发布日期 -->\n    updatedDate: 2023/01/01   <!-- 修改日期-->\n    heroImage: \"\"             <!-- 文章头图 -->\n    top: true                 <!-- 展示在右上方 -->\n    mode: chinese             <!-- 首行缩进 -->\n    mode: collect             <!-- 文章不被rss收录 -->\n    ```\n\n2. 使用如下代码，会被标题替换，支持三级标题\n    ```\n    [TOC]\n    ```\n3. 内部已支持了`markdown`命令转化为`html`了\n    ```\n    :abbr[提示]{title=\"提示\"}\n    ```\n    效果：:abbr[提示]{title=\"提示\"}\n4. 支持面板\n\n    ```\n    ::::card\n    横排排版演示\n    :::card-title\n    横排排版演示\n    :::\n    ::::\n\n    ::::card{#vertical}\n    竖排排版演示\n    :::card-title\n    竖排排版演示\n    :::\n    ::::\n\n    ::::card{#vertical.center}\n    竖排居中排版演示\n    :::card-title\n    竖排居中排版演示\n    :::\n    ::::\n    ```\n\n    横排已经可以了，竖排感觉也没啥用。\n\n5. 可配置头图为文章中的第一张图片，只需要将配置的`showArticleHeroImage`设置为 true 即可。\n6. 文章提供了直接在 github 编辑功能，自行配置即可\n7. 增加`mermaid`渲染流程图时序图（暂时提供两个）\n    ````\n        ```flow\n        flowchart TD\n            A[/Christmas\\]\n            A -->|Get money| B[\\Go shopping/]\n            B --> C{Let me thinksssss<br/>ssssssssssssssssssssss<br/>sssssssssssssssssssssssssss}\n            C -->|One| D[/Laptop/]\n            C -->|Two| E[\\iPhone\\]\n            C -->|Three| F[Car]\n        ```\n    ````\n    ````\n        ```sequence\n        ```\n    ````\n8. 增加`mathjax`渲染公式\n\n    ```\n    $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$\n\n    $$\tx = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n    ```\n\n9. 提供`iframe`命令和`iframec`命令  \n   `iframe`为收缩框默认打开  \n   `iframec`为收缩框默认关闭\n\n    ```\n    ::iframe[流程图Demo]{url=/demo/flowchart.html}\n    ::iframec[流程图Demo]{url=/demo/flowchart.html}\n    ```\n\n    目前版本能够展示 url 的网页,效果如下：\n    ::iframe[流程图 Demo]{url=/demo/flowchart.html}\n    ::iframec[时序图]{url=/demo/sequence-diagrams.html}\n\n    <!-- ::iframe[BiliBili]{url=\"//player.bilibili.com/player.html?aid=690345969&bvid=BV1N24y117QE&cid=895902728&page=1\"} -->\n\n10. 提供`demo`命令\n\n    ````\n        :::demo\n        ```html\n        <div>\n            <div>before content<div>\n            text\n            <div>after content<div>\n        </div>\n        ```\n        :::\n    ````\n\n    效果：\n    :::demo\n\n    ```html\n    <div>\n        <div>\n            before content\n            <div>\n                text\n                <div>\n                    after content\n                    <div></div>\n                </div>\n            </div>\n        </div>\n    </div>\n    ```\n\n    :::\n\n    ```\n    ::demo{path=\"/demo/flowchart.html\"}\n    ```\n\n    效果：\n    ::demo{path=\"/demo/flowchart.html\"}\n\n## 配置\n\n该配置文件在`src/config.ts`中：\n\n1. `SITE_TYPE`:\n   值：`ESITETYPE.BLOG`,`ESITETYPE.WIKI`\n   默认值：`ESITETYPE.BLOG`\n   说明：博客模式与 wiki 模式，主要区别是左侧菜单是一个完整的文件树还是菜单树\n2. `Show_Sub_Article`\n   值：true,fasle\n   默认值：fasle\n   说明：在博客模式下，点击菜单显示的是所有孙子节点文章还是只显示子文章\n3. `PageSize`\n   值：number\n   默认值：10\n   说明：分页个数\n\n4. 待续\n\n## 截图欣赏\n\n![图 0](/article/PureWiki主题/2023-08-01_01-14-42-23.png)   \n\n## 开发计划\n\n-   [x] 图片 alt 显示\n-   [x] 上一页与下一页\n-   [x] 搜索(简陋实现，需改进)\n-   [x] `mdx`全局组件实现，无需引入(初步实现)\n-   [x] 文章不显示在文件夹下，而是点击文件夹展示文章列表文章不显示在文件夹下"},{"slug":"0杂文/服务器docker的升级","category":"blog","title":"服务器docker的升级","description":"","body":"\n今天本想升级一下alist的，结果刚执行到`docker pull xhofe/alist:latest`，就提示我`mediaType in manifest should be 'application/vnd.docker.distribution.manifest.v2+json' not 'application/vnd.oci.image.manifest.v1+json'`，这咋能忍？\n\n\n\n搜索了一番，发现应该是docker问题，需要将docker升级到最新版本。不过我之前忘记是怎么安装docker的了，通过此[文章](https://blog.csdn.net/tration/article/details/81199590)我执行`dpkg -s docker-ce`检查了一下，发现有这个包，于是就执行一下命令更新：\n```\nsudo apt-get update\nsudo apt-get upgrade docker-ce\n```\n十分的顺利\n\n执行`docker version`查看一下，确实更新了\n\n![图 0](/article/服务器docker的升级/2023-08-05_05-10-56-39.png)  \n\n不过此时`docker ps`,发现是空的，之前的应用没了，因此需要重新运行，这个有记录的话简单，因此记得时刻做好记录。"},{"slug":"CSS/a标签嵌套a标签","category":"blog","title":"a标签嵌套a标签","description":"","body":"\n> https://www.cnblogs.com/leungUwah/p/6234832.html\n\n:::demo\n```html\n<!-- a标签进行嵌套的时候 -->\n<a href=\"#outer\">outerA\n    <a href=\"#inner\">innerA</a>\n</a>\n\n<!-- 而浏览器则会解析成 -- >\n<a href=\"#outer\">outerA</a>\n<a href=\"#inner\">innerA</a>\n```\n:::\n\n"},{"slug":"CSS/css中line-height属性各个单位详解","category":"blog","title":"css中line-height属性各个单位详解","description":"","body":"\n我们都知道css中line-height属性用于调整行高，它的值有一些不同的单位，本文将详细介绍这些单位的作用和一些区别。\n\n语法规则如下\n\nline-height: normal | `<number>` | `<length>` | `<percentage>`\n\n如果子元素没有指定行高，那么将默认继承父元素的行高，继承的时候父元素行高带单位和不带单位有一些区别。\n\n为了方便，下面效果中我设置了背景颜色，以便观察行高到底是多少\n\n## normal\n\n设置值为normal时 行高根据浏览器默认决定，不同浏览器可能有不同的值。\n\n## 使用单位px\n\n使用px单位表示行高为多少像素\n:::demo\n```html\n<div style=\"font-size: 20px;\n\t\tline-height: 20px;\">\n\t\t\t<p style=\"background: orange;\">我是父元素 字体大小20px 行高25px</p>\n\t\t\t<div style=\"font-size:30px\n\t\t\t\">\n\t\t\t\t<p style=\"background: green;\">我是子元素的内容 字体大小30px 行高继承了父元素行高25px</p>\n\t\t\t</div>\n\t\t</div>\n```\n:::\n\n## 使用百分数或em单位\n\n120%和1.2em效果完全相同。如果某个元素设置行高为1.5em，它的行高就是 1.5乘以 它的字体大小\n\n:::demo\n```html\n<p style=\"font-size: 20px; line-height: 1.5em; background: #abcdef;\">我字体大小20px,行高1.5em 算出值就是20*1.5为30px</p>\n```\n:::\n\n如果上面这个例子 行高1.5em 其实它的行高是30px\n\n如果他有子元素，子元素继承的行高是它计算后的行高30px\n:::demo\n```html\n<div style=\"font-size: 20px; line-height: 150%;\">\n<p style=\"background: orange;\">我是父元素 字体大小20px 行高150% 计算后30px</p>\n<div style=\"font-size: 30px;\">\n<p style=\"background: green;\">我是子元素 字体30px 行高继承父元素行高30px</p>\n</div>\n</div>\n```\n:::\n\n## 不带单位\n\n不带单位表示行高为元素字体大小乘以该数字。如果子元素继承父元素的该属性，则只继承了该数字，实际行高由该系数乘以各个元素自己的字体大小而定\n\n:::demo\n```html\n<div style=\"font-size: 20px; line-height: 1.5;\">\n<p style=\"background: orange;\">我是父元素 字体大小20px 行高1.5 计算后30px</p>\n<div style=\"font-size: 30px;\">\n<p style=\"background: green;\">我是子元素 字体30px 行高继承系数1.5 计算后是45px</p>\n</div>\n</div>\n```\n:::\n\n## 总结\n\n由于不带单位的时候只继承了系数，推荐使用这种方式。"},{"slug":"CSS/img之间存在间隙","category":"blog","title":"img之间存在间隙","description":"","body":"\n\n## 现象\n\n根据如下Demo,你可以清楚的看到图片之间有着明显的间隔。\n\n:::demo\n```html\n<style>\n.box{\n    border: 1px solid #efefef;\n    padding: 5px;\n}\n</style>\n<div class=\"box\">\n    <div style=\"background-color: green;\">\n        <img style=\"background-color:red;\" src=\"https://blog.xieyaxin.top/favicon.svg\" alt=\"\">\n        <img style=\"background-color:red;\" src=\"https://blog.xieyaxin.top/favicon.svg\" alt=\"\">\n        <img style=\"background-color:red;\" src=\"https://blog.xieyaxin.top/favicon.svg\" alt=\"\">\n        <img style=\"background-color:red;\" src=\"https://blog.xieyaxin.top/favicon.svg\" alt=\"\">\n        <span style=\"background-color:red;\">文字</span>\n    </div>\n</div>\n```\n:::\n## 原因\n\nimg本身是行内元素，当多个img排列在一起的时候,它们之间如果有回车换行或者空格就会形成空隙。\n其实如图片文字等内联元素，它默认对齐方式都是和它的父级的 baseline 去进行对齐的，但是你对齐的是 baseline，撑开高度的却是元素整体的高度（bottom line），这样肯定就会造成一定的间隙。\n\n## 解决办法\n\n### 消除上下间隙\n\n1. 改变其垂直对齐方式–将其改变为block元素，但是该方法直接改变了img行内块的性质。\n```css\nimg{ display:block};\n```\n2. 改变其垂直对齐方式(无效)\n```css\nimg{vertical-align:top;}\n```\n3. 将最外层行高设为0\n```css\ndiv{ line-height:0 };\n```\n\n### 消除左右间隙\n\n1. 多个标签写在一行，不可有空格或者回车\n\n```html\n<img src=\"...\" style=\"...\"><img src=\"...\" style=\"...\">\n```\n\n2. 使用letter-spacing属性(会导致文字显示问题)\n```html\n<div style=\"letter-spacing:-800px\">\n    <img src=\"...\" style=\"...\">\n    <img src=\"...\" style=\"...\">\n</div>\n```\n\n3. 使用float进行浮动\n\n```css\nimg{float: left;}\n```\n\n### 额外解决办法\n\n直接用`flex`布局\n\n## 最终效果\n\n:::demo\n```html\n<style>\n.box{\n    border: 1px solid #efefef;\n    padding: 5px;\n}\n.box > div:after{\n    content: \"\";\n    display: table;\n    clear: both;\n}\n.box img, .box span{float: left;vertical-align:bottom;}\n</style>\n<div class=\"box\">\n    <div style=\"background-color: green;\">\n        <img style=\"background-color:red;\" src=\"https://blog.xieyaxin.top/favicon.svg\" alt=\"\">\n        <img style=\"background-color:red;\" src=\"https://blog.xieyaxin.top/favicon.svg\" alt=\"\">\n        <img style=\"background-color:red;\" src=\"https://blog.xieyaxin.top/favicon.svg\" alt=\"\">\n        <img style=\"background-color:red;\" src=\"https://blog.xieyaxin.top/favicon.svg\" alt=\"\">\n        <span style=\"background-color:red;\">文字</span>\n    </div>\n</div>\n```\n:::"},{"slug":"CSS/有关伪元素的思考","category":"blog","title":"有关伪元素的思考","body":"\n## 情景演绎\n\n当时，我看到一个链接，很快啊，就点进去了，然后无意中发现他们的标题元素是根据文本的宽度下方有一个浅色的条纹，当时觉得这不停简单的吗，就是一个h2元素里面包一个行内块元素吗，有啥稀奇的。为了验证下猜想，于是果断按了`F12`,一检查，根本没有子元素，就是一个元素加上两个伪元素实现的，当时也没猜透是怎么实现的，现在经过严谨的分析，开始本文的解说。\n\n:::demo\n```html\n<style>\n    h2 {\n        display: inline;\n        width: auto;\n        background: linear-gradient(to bottom, transparent 70%, rgba(26, 188, 156, .3) 0) no-repeat;\n    }\n    h2::before {\n        content: \"\";\n        margin-top: 1.2em;\n        display: block;\n    }\n    h2::after {\n        content: \"\";\n        margin-top: 1.2em;\n        display: block;\n    }\n</style>\n<div>上部元素</div>\n<h2>\n    标题\n</h2>\n<div>下部元素</div>\n```\n:::\n\n大家可以查看框架源码，可以真切的看到就是只有一个元素。\n\n## 详细重现\n\n为了能够更加深入整个话题，我重新设计了一个Demo。\n\n:::demo\n```html\n<style>\n        .red{\n            background: red;\n            display: inline;\n        }\n\n        .red::before{\n            content: \"\";\n            display: block;\n            margin-top: 25px;\n        }\n\n        .red::after{\n            content: \"\";\n            display: block;\n            margin-bottom: 15px;\n        }\n    </style>\n    <div id=\"a\">aaaaaa</div>\n    <div id=\"output1\"></div>\n    \n    <div class=\"top\">top</div>\n    <div class=\"red\">aaaaaa</div>\n    <div class=\"bottom\">bottom</div>\n    <div id=\"output2\"></div>\n    <script>\n        document.getElementById(\"output1\").innerText = `普通元素高度为：${document.querySelector('#a').offsetHeight}px`\n        document.getElementById(\"output2\").innerText = `中间元素的高度为：${document.querySelector('.red').offsetHeight}px`\n    </script>\n```\n:::\n\n可以看到，中间的元素的高度等于`21+15=36`px,相当于`aaaaaa`本身的高度加上after伪元素`margin`高度。但是为啥不加上before伪元素的`margin`高度呢？实际上，不是不加，如果将css改成这样，那么可以看到元素就是61px了。\n\n:::demo\n<style>\n.red{\n    background: red;\n    overflow: hidden;\n}\n\n.red::before{\n    content: \"\";\n    display: block;\n    margin-top: 25px;\n}\n\n.red::after{\n    content: \"\";\n    display: block;\n    margin-bottom: 15px;\n}\n</style>\n<div id=\"a\">aaaaaa</div>\n<div id=\"output1\"></div>\n\n<div class=\"top\">top</div>\n<div class=\"red\">aaaaaa</div>\n<div class=\"bottom\">bottom</div>\n<div id=\"output2\"></div>\n<script>\n    document.getElementById(\"output1\").innerText = `普通元素高度为：${document.querySelector('#a').offsetHeight}px`\n    document.getElementById(\"output2\").innerText = `中间元素的高度为：${document.querySelector('.red').offsetHeight}px`\n</script>\n:::\n\n由此，可以推断出，伪元素实际是如下结构：\n```\n<div>\n    ::before\n    text\n    ::after\n</div>\n\n=>\n\n<div>\n    <div>before content<div>\n    text\n    <div>after content<div>\n</div>\n```\n\n这种结构刚好与上面的情况符合：\n- before margin的高度没有计算上。  \n    这是由于margin的合并造成的，第一个元素如果存在margin-top,会把整个父元素也顶下来，解决办法是触发BFC即可。关于margin合并，可以看[这篇文章](https://www.jianshu.com/p/a7ead28910f4)。\n- 为啥要注释`display: inline;`  \n    因为不变的话就会变成如下结构。但行内元素是不能嵌套块状元素的，否则块状元素会失去其特性，这点后面分析出来在写一篇文章。\n    ```\n    <span>\n        <div>before content<div>\n        text\n        <div>after content<div>\n    </span>\n    ```"},{"slug":"CSS/组合选择符","category":"blog","title":"组合选择符","description":"CSS组合选择符","body":"\n> \t组合选择符说明了两个选择器之间的关系。\n\nCSS组合选择符包括各种简单选择符的组合方式。\n\n在 CSS3 中包含了四种组合方式:\n\n- 后代选择器(以空格` `分隔)\n- 子元素选择器(以大于`>`号分隔）\n- 相邻兄弟选择器（以加号`+`分隔）\n- 后续兄弟选择器（以波浪号`~`分隔）\n\n## 后代选择器\n\n后代选择器用于选取某元素的后代元素。\n\n以下实例选取所有 `<p>` 元素插入到 `<div>` 元素中: \n\n:::demo\n```html\n<style>\ndiv p\n{\n  background-color:yellow;\n}\n</style>\n<div>\n    <p>p Text</p>\n    <p>p Text</p>\n    <p>p Text</p>\n    <p>p Text</p>\n    <div>div Text</div>\n</div>\n```\n:::\n\n## 子元素选择器\n与后代选择器相比，子元素选择器（Child selectors）只能选择作为某元素直接/一级子元素的元素。\n\n以下实例选择了`<div>`元素中所有直接子元素 `<p>` ：\n:::demo\n```html\n<style>\ndiv>p\n{\n\tbackground-color:yellow;\n}\n</style>\n<h1>Welcome to My Homepage</h1>\n<div>\n<h2>My name is Donald</h2>\n<p>I live in Duckburg.</p>\n</div>\n\n<div>\n<span><p>I will not be styled.</p></span>\n</div>\n\n<p>My best friend is Mickey.</p>\n```\n:::\n\n## 相邻兄弟选择器\n\n相邻兄弟选择器（Adjacent sibling selector）可选择紧接在另一元素后的元素，且二者有相同父元素。\n\n如果需要选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器（Adjacent sibling selector）。\n\n以下实例选取了所有位于 `<div>` 元素后的第一个 `<p>` 元素:\n:::demo\n```html\n<style>\ndiv+p\n{\n\tbackground-color:yellow;\n}\n</style>\n<h1>文章标题</h1>\n\n<div>\n<h2>DIV 内部标题</h2>\n<p>DIV 内部段落。</p>\n</div>\n\n<p>DIV 之后的第一个 P 元素。</p>\n\n<p>DIV 之后的第二个 P 元素。</p>\n```\n:::\n\n## 后续兄弟选择器\n后续兄弟选择器选取所有指定元素之后的相邻兄弟元素。\n\n以下实例选取了所有 `<div>` 元素之后的所有相邻兄弟元素 `<p>` : \n\n:::demo\n```html\n<style>\ndiv~p\n{\n\tbackground-color:yellow;\n}\n</style>\n<p>之前段落，不会添加背景颜色。</p>\n<div>\n<p>段落 1。 在 div 中。</p>\n<p>段落 2。 在 div 中。</p>\n</div>\n\n<p>段落 3。不在 div 中。</p>\n<p>段落 4。不在 div 中。</p>\n```\n:::"},{"slug":"CSS/行内元素的细小留白","category":"blog","title":"行内元素的细小留白","description":"一般来说，行内元素会出现几个像素的底部留白，这是浏览器决定的","body":"\n## 现象\n\n根据如下Demo,你可以清楚的看到上面的图片跟下面的文字有着明显的间隔。\n\n:::demo\n```html\n<style>\n.box{\n    border: 1px solid #efefef;\n    padding: 5px;\n}\n</style>\n    <div class=\"box\">\n        <!-- <div style=\"line-height: 0;\">\n            <span style=\"background-color: red;\">aa</span>\n            <span style=\"background-color: red;\">aa</span>\n        </div> -->\n        <div style=\"background-color: green;\">\n            <span>文字文字</span>\n            <img src=\"/favicon.svg\" alt=\"\">\n        </div>\n        <div style=\"background-color: red;clear: both;\">第二行文字</div>\n    </div>\n```\n:::\n\n## 产生原因\n\nimg属于行内块元素，div中的img的vertical-align默认属性是baseline。\n\n![图 1](/article/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%86%E5%B0%8F%E7%95%99%E7%99%BD_2022-11-21_21-14-25-56.png)  \n\n文本与图片的垂直对齐基线的位置并不是相同的：\n\n在**文本中，基线是字符的下边缘**。字符的下边缘和字符元素的底边是有一定的距离的（也就是行高）。\n**在图片中，基线就是图片的下边缘**。\n\n所以其实可以看到图片的底边是和字符的底边对齐的，这才导致了图片底部产生间隙。\n\n## 解决办法\n\n基于以上的原理，我们可以推导出解决办法：让字符的底边和图片的底边垂直对齐，就可以解决图片底部间隙的问题了。\n\n1. 将img标签设置为块级元素  \n    ```\n    img {\n\t    display: block;\n\t}\n    ```\n2. 设置图片的垂直对齐方式   \n    ```\n    img {\n        vertical-align: top/text-top/middle/bottom/text-bottom\n    }\n    ```\n3. 改变父元素的宽和高属性   \n    如果父对象的宽、高固定，图片大小随父对象而定，那么可以添加以下的一个属性来去掉图片下面的空间像素：\n    ```\n    div {\n        width: 100px;\n        height: 300px;\n        overflow: hidden;\n    }\n    ```\n4. 为img设置浮动    \n    ```\n    img {\n        float: left;\n    }\n    ```\n5. 为父元素设置`font-size: 0`\n    ```\n    div {\n        font-size: 0;\n    }\n    ```\n6. 为父元素设置`line-height: 0`\n    ```\n    div {\n        line-height: 0;\n    }\n    ```\n\n## 最终实现\n\n:::demo\n```html\n<style>\n.box{\n    border: 1px solid #efefef;\n    padding: 5px;\n}\n</style>\n    <div class=\"box\">\n        <!-- <div style=\"line-height: 0;\">\n            <span style=\"background-color: red;\">aa</span>\n            <span style=\"background-color: red;\">aa</span>\n        </div> -->\n        <div style=\"background-color: green;\">\n            <span>文字文字</span>\n            <img style=\"vertical-align:bottom;\" src=\"/favicon.svg\" alt=\"\">\n        </div>\n        <div style=\"background-color: red;clear: both;\">第二行文字</div>\n    </div>\n```\n:::"},{"slug":"开源项目/怎么阅读开源项目的源码","category":"blog","title":"怎么阅读开源项目的源码","description":"","body":"\n## 思路\n\n1. github 的 commit 历史记录\n\n例如[vue3 的源码](https://github.com/vuejs/core/commits/main)的提交，可以清晰的看到每一个提交的具体内容。\n\n2. git log --reverse\n\n执行`git log --oneline --reverse > commits.txt`,会将所有的提交信息打印到 commits.txt 中，之后可以按顺序一个个 checkout 即可\n\n## 工具\n\n::collect[ excalidraw ||白板绘制工具]{url=\"https://excalidraw.com/ || 地址\"}\n::collect[ excalidraw 中文版 ||白板绘制工具]{url=\"https://handraw.top/ || 地址\"}\n::collect[ 幕布 || 极简大纲笔记，一键生成思维导图]{url=\"https://mubu.com/home || 网址\"}\n"},{"slug":"文字处理/怎么用unified.js自定义元素输出","category":"blog","title":"怎么用unified.js自定义元素输出","description":"","body":"\n## 什么是unified.js？\n\n进而言之，他们能将内容编译为语法树，将语法树编译为内容。它能够处理`markdown`,`html`或者纯文本，将其转化为结构化数据，再将结构化数据输出对应文件，这几者之间可操作的事情就多了。\n\nUnified本身是一个相当小的模块，充当统一处理不同内容格式的接口。围绕某种格式，有一个生态系统,其中包括：\n\n*   [remark](https://unifiedjs.com/explore/project/remarkjs/remark/) Markdown\n*   [rehype](https://unifiedjs.com/explore/project/rehypejs/rehype/) HTML\n*   [retext](https://unifiedjs.com/explore/project/retextjs/retext/) Natural language\n*   [redot](https://unifiedjs.com/explore/project/redotjs/redot/) Graphviz\n\n语法树的规范如下：\n\n*   [unist](https://github.com/syntax-tree/unist) Universal Syntax Tree\n*   [mdast](https://github.com/syntax-tree/mdast) Markdown Abstract Syntax Tree format\n*   [hast](https://github.com/syntax-tree/hast) HTML Abstract Syntax Tree format\n*   [xast](https://github.com/syntax-tree/xast) XML Abstract Syntax Tree format\n*   [esast](https://github.com/syntax-tree/esast) ECMAScript Abstract Syntax Tree format\n*   [nlcst](https://github.com/syntax-tree/nlcst) Natural Language Concrete Syntax Tree format\n\n还有一些其他的构建块:\n\n*   [syntax\\-tree](https://github.com/syntax-tree) Low-level utilities for building plugins\n*   [vfile](https://unifiedjs.com/explore/package/vfile/) Virtual file format for text processing\n*   [MDX](https://unifiedjs.com/explore/project/mdx-js/mdx/) Markdown and JSX\n\n## 工作流程\n\n说了这么多，那他们是怎么工作的呢？其实就是分了三步：\n\n1. 解析：\n    无论您的输入是 Markdown、HTML 还是散文，都需要将其解析为可行的格式。这种格式称为语法树。规范（例如 mdast）定义了这种语法树的格式。处理器负责创建它们。\n2. 转化：\n    这就是魔术发生的地方。用户编写插件及其运行顺序。插件插入此阶段并转换和检查它们获得的格式。\n3. 输出：\n    最后一步是采用（调整后的）格式并将其字符串化为Markdown，HTML或文本（可能与输入格式不同！）\n\n[unified](https://unifiedjs.com/explore/package/unified/) 可以 Node.js 中以编程方式使用。通过构建步骤，它也可以在浏览器中使用处理器的 CLI 版本、Grunt 插件、Gulp 插件也存在\n\n[unified](https://unifiedjs.com/explore/package/unified/)的独特之处在于它可以在同一过程中在格式之间切换，例如Markdown到HTML。这允许更强大的合成，以下插件桥接格式：\n\n*   [`remark-rehype`](https://unifiedjs.com/explore/package/remark-rehype/) Markdown to HTML\n*   [`rehype-remark`](https://unifiedjs.com/explore/package/rehype-remark/) HTML to Markdown\n*   [`remark-retext`](https://unifiedjs.com/explore/package/remark-retext/) Markdown to prose\n*   [`rehype-retext`](https://unifiedjs.com/explore/package/rehype-retext/) HTML to prose\n\n> 参考\n> 1. https://www.npmjs.com/package/remark-html\n> 2. https://marvinsblog.net/post/2022-04-18-markdown-with-remark/\n> 3. https://unifiedjs.com/learn/\n> 4. https://github.com/vmarkdown/remark-render/blob/master/src/compiler.js\n"},{"slug":"Vue/Vue3/vModelText的探究","category":"blog","title":"vModelText的探究","description":"","body":"\n## 起始\n\n今天学习掘金的文章，看到一篇[关于vue3技巧的文章](https://juejin.cn/post/7264532077574668303#heading-0)，学习到主要两个点，如下：\n1. `pinia-plugin-persistedstate` 插件\n    这应该是pinia的持久化插件，vuex时期也有类似的，既然是别人推荐的，想必也是好用的。\n2. `vModelText`\n    这个是一个官方的自定义指令，对应的指令是`v-model`,这竟然从没了解过，可以给其添加修饰符\n    ```ts\n    <script setup>\n    import { ref, vModelText } from 'vue'\n\n    const value = ref(\"\")\n\n    // 为' v-model '指令定义一个名为'capitalize '的自定义修饰符\n    vModelText.beforeUpdate = function (el, { value, modifiers }) {\n        // 检查' v-model '指令中是否存在' capitalize '修饰符\n        if (value && modifiers.capitalize) {\n        el.value = el.value.toUpperCase()\n        }\n    }\n    </script>\n\n    <template>\n    <input type=\"text\" v-model.capitalize=\"value\" />\n    </template>\n    ```\n\n## 探究\n\n其源码在[这里](https://gitee.com/fe-mirror/vue3/blob/main/packages/runtime-dom/src/directives/vModel.ts#L41), 可以看到它主要是一个指令，"},{"slug":"前端/库/floating-ui使用方式","category":"blog","title":"floating-ui使用方式","description":"","body":"\n::demo{path=\"https://play.vuejs.org/#eNp9VFFP2zAQ/iu3bBKtVhIG20tWEGPigUkbaOvbMok0viQGx7Zsp01U9b/vYrcpIMRTnbvvO3/f3bmb6JvW8arFKI3mtjBcO7DoWn2RSd5oZRxswGA5AyV/qlY6ZLCF0qgGjoh19ARVqEa3Du+U5Y4rOYNScL0HZ9FlKVTuuKyOW54w1WTR10xmciw7mUzh/AI2mQQqJa0brkWDskA4B6aKtkHp4grdtcDheNXfsEkWjagsmlLFPXl/25vcPShQA/mZiclYfbATwLOgEUCLvPDVUrLnlM6iWUgkCSxMT/obtRokuJpbEFwiLFGodQyLGsEpJRw1aM2FGGlqhYbuWRMFYcVxPfT2yAKyCt8FVMMZE7jODabwd2jxZPpvyGynMZHkZLKBbgY9fY/tBLhdPmDh4txaXsnJ3klsXS/I2Q4EpEmncP9h0291d78zAyCwJIsU7oZwiG5Dr/3PdprJeRKWh9Zm7rCh1jikM8Cc8RVwdv5sUBfzhMIv8odh+ATAInTIo3b4efKkOH16A3RcKtYHG6WS7rjMGy76FGwu7bFFw8tB5sB4f1gqD19z5uoUPp2c6M47qpFXNdk9RJbKMDQpnOoOWG5regFLmvyjTza5qbhM4WS8YFw8X1/vFimFfGmVoNUKNYlfGVp8lkJl8t4Hdc4YEalY/IV2Z7fMQtHd65p7Jl1Bnfamo1kUnt5xk+v4wSpJT9jfme0SNovS/Wxfe3/D2tbOaZsmScEk1WAo+MrEEl0idZO8pFx+ij/Hp8lHtMT24ydFpMNZenMlr16oGN4SF2hu9dCB52pyQVv+w8ecaXG3a8SpsXh8Jf5guyD4ziANdEVLNOYczQBdSF//+YUdncdko1grCP1G8jf6yZDGALuisZDsJziv9sY3lbqxsNedQ2n3pgahvhsen0X0v/j9DesHuWfx2djF7X8z+d47\"}"},{"slug":"小说/罪大恶极之人/0 序","category":"blog","title":"0 序","description":"","body":"\n这一年是黑暗的一年\n\n"}]